# =============================================================================
# NautiPi Service YAML Template
# =============================================================================
# PURPOSE
# - Declaratively describe how NautiPi installs, configures, runs, checks and links a service.
# - Keep backend simple: most logic should be CLI commands in lifecycle.*.commands.
#
# STRING INTERPOLATION
# - You can reference any user input from `inputs:` in ANY STRING field using: ${inputs.NAME}
#   Example: "-p ${inputs.SIGNALK_PORT}:3000" or "http://localhost:${inputs.WEB_PORT}/"
# - Escaping: write \${inputs.NAME} to keep it literal (no interpolation).
# - Types: interpolation yields strings; the runner will coerce obvious numeric/boolean fields
#   (e.g. ports[].port) when possible.
# - Validation: if an input is `required: true` but missing, the runner will fail with a clear error.
# - Only add `inputs` that you actually need for install/config (every input becomes UI work which might confuse users).
# - inputs[].type: password OR inputs[].secret: true → mask values in logs/UI (e.g., ******).
# =============================================================================

apiVersion: nautipi.io/v1                   # required – API version (fixed)
kind: Service                               # required – always "Service"

metadata:
  id: "<service-id>"                        # required – unique, machine-readable (a-z0-9-_)
  displayName: "<Service Name>"             # required – short UI name (≤ 30 chars)
  version: "1.0.0"                          # required – semver for THIS descriptor (not the app)
  description: |                            # required – 1–3 lines: what this service does
    <Short description of the service or plugin functionality>
  author: "<Author or Project>"             # optional – credits in UI
  homepage: "<https://project.url>"         # optional – docs/homepage
  icon: "<https://project.url/icon.jpg>"    # optional – icon of the project

# -----------------------------------------------------------------------------
# inputs: Values collected from the user (once) and available everywhere via ${inputs.NAME}
# Fields:
# - name (required): machine name [A-Z0-9_ recommended]; used as ${inputs.NAME}
# - label (required): shown in UI
# - type (required): string | number | boolean | password
# - default (optional): default value if user doesn't change it
# - required (optional): true/false, default false
# - secret (optional): true to mask in logs/UI (implied when type=password)
# - description (optional): help text in UI
# - pattern / min / max (optional): basic validation hints (optional)
# Keep this section minimal; prefer sensible defaults.
# -----------------------------------------------------------------------------
inputs:
  # Example inputs (delete if not needed):
  # - name: "WEB_PORT"
  #   label: "Web Port"
  #   type: "number"
  #   default: 3000
  #   description: "HTTP port the service will listen on"
  #
  # - name: "ADMIN_USER"
  #   label: "Admin User"
  #   type: "string"
  #   required: true
  #
  # - name: "ADMIN_PASS"
  #   label: "Admin Password"
  #   type: "password"
  #   required: true
  #   secret: true
  #
  # - name: "ENABLE_WRITEBACK"
  #   label: "Allow write-back to upstream"
  #   type: "boolean"
  #   default: true

# -----------------------------------------------------------------------------
# injection (ADVANCED / OPTIONAL):
# Prefer shell-based config in lifecycle.postInstall commands for MVP.
# Use injection only if you must template files declaratively.
# -----------------------------------------------------------------------------
# injection:
#   - input: "<INPUT_NAME>"
#     target:
#       type: "<env_file|docker_compose|replace_string>"
#       file: "<path/to/file>"
#       # for type=env_file: provide key
#       key: "<ENV_KEY>"
#       # for type=docker_compose: YAML path to set (dot notation)
#       key_path: "services.app.environment.MY_VAR"
#       # for type=replace_string: placeholder to replace
#       search: "<PLACEHOLDER>"

spec:
  category: "<navigation|sensor|system|utility|media|plugin>"   # required – UI grouping
  icon: "<icon-name>"                                           # optional – UI icon identifier

  # -----------------------------------------------------------------------------
  # lifecycle: How to install/update/remove/configure the service.
  # Each commands[].command is a shell line; set sudo:true if root is needed.
  # Use ${inputs.NAME} directly in commands.
  # Make commands IDEMPOTENT where possible (use '|| true', check existence, etc.).
  #
  # CONDITIONAL COMMANDS (onlyIf):
  # - Add onlyIf to a command to guard it by simple conditions (all are AND-combined):
  #   onlyIf:
  #     serviceInstalled: "signalk"             # or ["signalk","avnav"]
  #     serviceNotInstalled: "mosquitto"        # optional
  #     fileExists: "/etc/my.conf"              # or ["/a","/b"]
  #     cmd: "test -S /var/run/docker.sock"     # shell returns 0 → true
  # - [NEW] You may also use version constraints:
  #     serviceInstalled:
  #       - id: "signalk"
  #         version: ">=2.0.0"                  # Only run if installed AND version matches
  # - [NEW] Optional OR support:
  #     onlyIfAny:                              # Command runs if ANY listed condition passes
  #       - serviceInstalled: "signalk"
  #       - serviceInstalled: "avnav"
  #
  # RECONFIGURE STEP (enable/disable integrations & rollback):
  # - lifecycle.reconfigure.commands holds idempotent integration steps that can be
  #   * run after initial install,
  #   * re-run later when optional dependencies appear/disappear,
  # - Put both "enable" and "disable" sides here using onlyIf.serviceInstalled / serviceNotInstalled if needed.
  #
  # [NEW] Per-command robustness:
  # - timeoutSeconds: <int>        # Kill the command after N seconds (0=no timeout)
  # - continueOnError: true|false  # If true, do not stop the sequence on this command's failure
  # -----------------------------------------------------------------------------
  lifecycle:
    preInstall:
      commands:                                # optional – prepare system (repos, deps, docker)
        # - command: "apt-get update"
        #   sudo: true
        #   timeoutSeconds: 60          # Optional timeout per command
        #   continueOnError: false      # Continue even if this step fails

    install:
      commands:                                # required – actual installation steps
        - command: "<install command 1>"
          sudo: true
          # timeoutSeconds: 300         # Example timeout
          # continueOnError: false
        - command: "<install command 2>"
          sudo: true
        # Examples:
        # - command: "apt-get install -y avnav"
        #   sudo: true
        # - command: "docker pull signalk/signalk-server:latest"
        #   sudo: true

    postInstall:
      commands:                                # optional – config/enable/start after install
        # - command: "systemctl enable --now <service>"
        #   sudo: true

    reconfigure:    # Re-run-able, condition-aware config/integration step
      commands:
        # --- EXAMPLE: Enable integration when SignalK is present
        # - command: "/usr/local/bin/enable-signalk --host 127.0.0.1 --port ${inputs.SIGNALK_PORT}"
        #   sudo: true
        #   onlyIf:
        #     serviceInstalled: "signalk"
        #
        # --- EXAMPLE: Disable integration (rollback) when SignalK is absent
        # - command: "/usr/local/bin/disable-signalk"
        #   sudo: true
        #   continueOnError: true      # Best-effort rollback
        #   onlyIf:
        #     serviceNotInstalled: "signalk"

    update:
      package_manager: "<apt|docker|docker-compose|npm|pip|custom>"  # required – how to update
      custom_commands:
        - command: "<update command>"
          sudo: true
        # - command: "docker pull myimage:latest && docker restart mysvc"
        #   sudo: true

    uninstall:
      commands:                                # required – clean removal (stop, rm files/containers)
        - command: "<uninstall command 1>"
          sudo: true

    checkInstall:
      command: "<which binary || test -f /path/to/installed/file>"   # required – exit 0 if installed
      sudo: false

  # -----------------------------------------------------------------------------
  # service: How NautiPi manages the running service (start/stop/status).
  # Choose ONE type and fill its subsection. Others can be omitted.
  # -----------------------------------------------------------------------------
  service:
    type: "<systemd|docker|docker-compose|process|custom|none>"   # required

    systemd:
      unit: "<service.service>"             # if type=systemd – unit name to manage

    docker:
      image: "<docker-repo/image:tag>"      # if type=docker – image to run
      name: "<container_name>"              # optional – container name
      ports:
        - "3000:3000"                       # optional – host:container (can use ${inputs.WEB_PORT}:3000)
      volumes:
        # - "/host/path:/container/path"
      env:                                  # optional – inline env for 'docker run'
        # ENV_VAR: "value"
      envFile:                              # optional – host env-file(s)
        # - "/opt/<service>/.env"
      args: "<additional docker run args>"  # optional – appended to 'docker run'

    docker-compose:
      file: "<path/to/docker-compose.yml>"  # if type=docker-compose – compose file
      project: "<project-name>"             # optional – compose project (defaults to metadata.id)

    process:
      start: "<start-command>"              # if type=process – how to start
      stop: "<stop-command>"                # how to stop
      pidFile: "<path/to/pid.file>"         # optional – PID file for status
      cwd: "<working-directory>"            # optional – working directory

    custom:
      start:                                # if type=custom – define explicit start/stop/status commands
        - command: "<custom start command>"
          sudo: true
      stop:
        - command: "<custom stop command>"
          sudo: true
      status:
        - command: "<custom status command>"
          sudo: true

  # -----------------------------------------------------------------------------
  # statusChecks: Define one or more health checks. All required checks must pass.
  # Types:
  # - systemd: { unit }
  # - http:    { url, expect("200" or regex), timeout }
  # - tcp:     { host, port }
  # - process: { name }
  # - custom:  { command, expect(regex) }
  # Interpolation works in URLs/hosts/ports (e.g., http://localhost:${inputs.WEB_PORT}/)
  # -----------------------------------------------------------------------------
  statusChecks:
    - type: "systemd"
      unit: "<service.service>"
    - type: "http"
      url: "http://localhost:3000/status"
      expect: "200"
      timeout: 5
    # - type: "tcp"
    #   host: "localhost"
    #   port: 1883
    # - type: "process"
    #   name: "<process-name>"
    # - type: "custom"
    #   command: "curl -fsS http://localhost:3000/health"
    #   expect: "ok"
 
  # -----------------------------------------------------------------------------
  # config: (OPTIONAL) – Structured config files + UI editor schema
  #
  # GOAL
  # - Provide a simple form-based editor for common config files (yaml/json/xml/ini/properties/env/conf).
  #
  # FILES
  # - files[]: one or more config sources.
  #   - path (required): absolute file path on host (strings support ${inputs.*})
  #   - format (required): "yaml" | "json" | "xml" | "ini" | "properties" | "env" | "conf" | "file"
  #       yaml/json: parsed with dot-paths (arrays via [index])
  #       ini:       "section.key" or just "key" (no section)
  #       properties: flat "key"
  #       env:       flat "KEY" (KEY=VAL lines)
  #       conf:      flat key=value (like sysconfig) – parser treats as simple map
  #       xml:       XPath OR simplified path:
  #                   - "root.child.grandchild" → element text
  #                   - "root.child@attr"       → attribute
  #                 (choose one convention for your project; see schema.key)
  #       file:      raw text editor only (no schema-based fields)
  #   - reload (required): what to do after save
  #       "none" (default), or any shell command to run (e.g., "systemctl restart <svc>").
  #       Interpolation works: "docker restart ${inputs.CONTAINER_NAME}"
  #   - reloadSudo (required): 
  #   - description (optional): text shown above the editor/form
  #
  # SCHEMA (per file)
  # - schema[]: array defining form fields mapped to keys inside the file.
  #   Field:
  #     - key (required): path to value inside the file
  #         yaml/json:     "server.port", "listeners[0].host"
  #         ini:           "section.key" or "key"
  #         properties/env/conf: "KEY"
  #         xml:           XPath (e.g., "/config/server/port") OR simplified "config.server.port"
  #                        use "@attr" for attributes, e.g., "server.@port"
  #     - type (required): string | integer | number | boolean | password | select
  #     - required (optional): true/false
  #     - description (optional): help text
  #     - default (optional): default if key absent (strings support ${inputs.*})
  #     - min / max (optional): numbers only
  #     - minLength / maxLength / pattern (optional): strings only (pattern is regex)
  #     - enum (optional): array of allowed values (for select OR restrict string)
  #     - enumNames (optional): labels for enum entries (UI nicety)
  #
  # NOTES / LIMITS
  # - Comments in yaml/ini may be lost on write (parser dependent). Use format "file" if preserving exact text matters.
  # - Arrays: use explicit indices (e.g., "servers[0].port") – MVP supports updating existing indices or creating simple paths.
  # - Interpolation applies to all STRING fields (path, reload, defaults, etc.).
  # -----------------------------------------------------------------------------
  config:
    files:
      # Structured file with form schema
      - path: "/etc/<service>/config.yaml"     # supports ${inputs.*}
        format: "yaml"                          # yaml|ini|json|xml|env|conf|properties|file
        reload: "systemctl restart <service>"   # "none" or a shell command (interpolation allowed)
        reloadSudo: true
        # Safe write options (recommended on system configs)
        writeSudo: true                 # Write file with sudo
        createIfMissing: true           # Create missing file/dirs before write
        backupSuffix: ".bak"            # Save <file>.bak before overwrite
        atomicWrite: true               # Write to temp + atomic rename
        owner: "root"                   # chown after write (optional)
        group: "root"                   # chgrp after write (optional)
        mode: "0644"                    # chmod after write (optional)
        description: "Main configuration"
        schema:
          - key: "server.port"
            type: integer
            required: true
            description: "HTTP Port"
            min: 1024
            max: 65535
          - key: "auth.enabled"
            type: boolean
            description: "Enable authentication"
          # Examples of other field types:
          # - key: "auth.mode"
          #   type: select
          #   enum: ["none", "basic", "oauth2"]
          #   enumNames: ["No auth", "Basic Auth", "OAuth 2.0"]
          # - key: "admin.password"
          #   type: password
          #   required: false
          #   description: "Admin password (leave blank to keep current)"
          # - key: "listeners[0].host"
          #   type: string
          #   default: "0.0.0.0"

      # Raw file (no form fields) – shows a simple text editor
      - path: "/etc/<service>/sub-config.conf"
        format: "file"
        reload: "none"
        reloadSudo: false
        # Safe write options also available for raw files:
        writeSudo: false               # Set true if file requires root to edit
        createIfMissing: false
        backupSuffix: ".bak"
        atomicWrite: true
        description: "Main configuration"

  # -----------------------------------------------------------------------------
  # actions (OPTIONAL):
  # Extra buttons in UI that run commands (backup, reset, etc.).
  # NOTE: start/stop/restart for systemd/docker are usually handled automatically.
  # Fields: name, command, sudo, confirm, description, icon
  # -----------------------------------------------------------------------------
  actions:
    # - name: "Restart Service"
    #   command: "systemctl restart <service>"
    #   sudo: true
    #   confirm: false
    #   description: "Restart the service"
    #
    # - name: "Backup Config"
    #   command: "/usr/bin/<service>-backup"
    #   sudo: true
    #   confirm: true
    #   description: "Backup configuration and data"
    #
    # - name: "Apply Integrations"
    #   builtin: "reconfigure"            # Runs lifecycle.reconfigure.commands
    #   confirm: false
    #   description: "Re-run conditional integration & rollback steps"

  # -----------------------------------------------------------------------------
  # links: Helpful URLs shown in UI (e.g., Web UI, Docs).
  # Use localhost or explicit host:port; the UI may rewrite to the device IP for convenience.
  # Interpolation works (e.g., http://localhost:${inputs.WEB_PORT}/).
  # -----------------------------------------------------------------------------
  links:
    - title: "Web UI"
      url: "http://localhost:3000/"
      description: "Open the service's web interface"
      webservice: true       # Link to the webservice itself (major button)
    # - title: "Documentation"
    #   url: "<https://project.docs.url>"
    #   description: "Project documentation"
    #   webservice: false

  # -----------------------------------------------------------------------------
  # dependsOn: Declare relationships to other services by ID.
  # - required: service MUST be present (installer may block until installed).
  # - optional: service enhances functionality if present (no hard block).
  # Version constraints are advisory (semver, e.g., >=1.0.0).
  # NOTE: Declaration does not auto-install dependencies; it informs UI/flows.
  # -----------------------------------------------------------------------------
  dependsOn:
    required: []   # e.g., [{ id: "database", version: ">=1.0.0" }]
    optional: []   # e.g., [{ id: "signalk",  version: ">=1.0.0" }]
