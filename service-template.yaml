# =============================================================================
# NautiPi Service YAML Template
# =============================================================================
# PURPOSE
# - Declaratively describe how NautiPi installs, configures, runs, checks and links a service.
# - Keep backend simple: most logic should be CLI commands in lifecycle.*.commands.
#
# EXECUTION MODEL
# - NautiPi runs as a non-root service. Any command with sudo: true triggers a UI sudo prompt once per job.
# - The sudo credential is verified via PAM, cached in memory for the job only (short TTL), and never persisted.
#
# STRING INTERPOLATION
# - You can reference any user input from `inputs:` in ANY STRING field using: ${inputs.NAME}
#   Example: "-p ${inputs.SIGNALK_PORT}:3000" or "http://localhost:${inputs.WEB_PORT}/"
# - Escaping: write \${inputs.NAME} to keep it literal (no interpolation).
# - Types: interpolation yields strings; the runner will coerce obvious numeric/boolean fields
#   (e.g. ports[].port) when possible.
# - Validation: if an input is `required: true` but missing, the runner will fail with a clear error.
# - Only add `inputs` that you actually need for install/config (every input becomes UI work and can confuse users).
# - inputs[].type: password OR inputs[].secret: true → mask values in logs/UI (e.g., ******).
#
# SAFETY
# - Commands run in a job with streaming logs. Use small, idempotent steps.
# - Quote/escape user-provided data in commands (the runner applies safe quoting, but be defensive).
# - Prefer package manager/container images from trusted sources.
#
# NETWORKING & HTTP
# - NautiPi is HTTP-only by design (boats may be offline for months; public CAs unreachable).
# - Do NOT assume TLS. Links should use http://localhost:PORT or device IP/hostname.
# - Optional 'spec.network' hints allow the firewall manager to expose ports only to the boat LAN (hotspot/safe networks).
#   Unsafe uplinks (e.g., marina Wi-Fi) are firewalled from inbound access by default.
#
# HEALTH & RECONCILE
# - 'statusChecks' define readiness/liveness. The reconciler uses these and dependencies to converge on desired state.
# - 'reconfigure' contains idempotent integration steps (enable/disable) and can be re-run safely.
# =============================================================================

apiVersion: nautipi.io/v1                   # required – API version (fixed)
kind: Service                               # required – always "Service"

metadata:
  id: "<service-id>"                        # required – unique, machine-readable (a-z0-9-_)
  displayName: "<Service Name>"             # required – short UI name (≤ 30 chars)
  version: "1.0.0"                          # required – semver for THIS descriptor (not the app)
  description: |                            # required – 1–3 lines: what this service does
    <Short description of the service or plugin functionality>
  author: "<Author or Project>"             # optional – credits in UI
  homepage: "<https://project.url>"         # optional – docs/homepage
  icon: "<https://project.url/icon.jpg>"    # optional – icon of the project

# -----------------------------------------------------------------------------
# inputs: Values collected from the user (once) and available everywhere via ${inputs.NAME}
# Fields:
# - name (required): machine name [A-Z0-9_ recommended]; used as ${inputs.NAME}
# - label (required): shown in UI
# - type (required): string | number | boolean | password
# - default (optional): default value if user doesn't change it
# - required (optional): true/false, default false
# - secret (optional): true to mask in logs/UI (implied when type=password)
# - description (optional): help text in UI
# - pattern / min / max (optional): basic validation hints (optional)
# Keep this section minimal; prefer sensible defaults.
# -----------------------------------------------------------------------------
inputs:
  # Example inputs (delete if not needed):
  # - name: "WEB_PORT"
  #   label: "Web Port"
  #   type: "number"
  #   default: 3000
  #   description: "HTTP port the service will listen on"
  #
  # - name: "ADMIN_USER"
  #   label: "Admin User"
  #   type: "string"
  #   required: true
  #
  # - name: "ADMIN_PASS"
  #   label: "Admin Password"
  #   type: "password"
  #   required: true
  #   secret: true
  #
  # - name: "ENABLE_WRITEBACK"
  #   label: "Allow write-back to upstream"
  #   type: "boolean"
  #   default: true

# -----------------------------------------------------------------------------
# injection (ADVANCED / OPTIONAL):
# Prefer shell-based config in lifecycle.postInstall commands for MVP.
# Use injection only if you must template files declaratively.
# -----------------------------------------------------------------------------
# injection:
#   - input: "<INPUT_NAME>"
#     target:
#       type: "<env_file|docker_compose|replace_string>"
#       file: "<path/to/file>"
#       # for type=env_file: provide key
#       key: "<ENV_KEY>"
#       # for type=docker_compose: YAML path to set (dot notation)
#       key_path: "services.app.environment.MY_VAR"
#       # for type=replace_string: placeholder to replace
#       search: "<PLACEHOLDER>"

spec:
  category: "<navigation|sensor|system|utility|media|plugin>"   # required – UI grouping
  icon: "<icon-name>"                                           # optional – UI icon identifier (name token)

  # -----------------------------------------------------------------------------
  # network (OPTIONAL): Hints for NautiPi's firewall manager.
  # - Use to declare which ports should be reachable from the boat LAN (hotspot/safe).
  # - 'wan' exposure is discouraged; uplink is considered unsafe by default.
  # -----------------------------------------------------------------------------
  network:
    # When true, service should start only when at least one network is online
    # (hotspot or marked safe LAN). Default: false.
    dependsOnNetwork: false

    ports:
      # - port: 3000
      #   protocol: "tcp"           # tcp | udp
      #   exposure: "lan"           # lan | wan | both | none
      #   description: "HTTP UI"

  # -----------------------------------------------------------------------------
  # lifecycle: How NautiPi installs/updates/removes/configures the service.
  # Each commands[].command is a shell line; set sudo:true if root is needed.
  # Commands execute inside a job with live logs. Keep them IDEMPOTENT.
  #
  # CONDITIONAL COMMANDS (onlyIf / onlyIfAny):
  # - Guard steps by conditions (all are AND-combined inside onlyIf):
  #   onlyIf:
  #     serviceInstalled: "signalk"         # or ["signalk","avnav"] or [{id:"signalk",version:">=2.0.0"}]
  #     serviceNotInstalled: "mosquitto"    # optional
  #     fileExists: "/etc/my.conf"          # string OR ["pathA","pathB"] – ALL must exist
  #     cmd: "test -S /var/run/docker.sock" # shell returns 0 → true
  # - OR logic:
  #   onlyIfAny:
  #     - serviceInstalled: "signalk"
  #     - serviceInstalled: "avnav"
  #
  # RECONFIGURE STEP:
  # - 'reconfigure.commands' holds idempotent integration steps that can be run:
  #   * after first install,
  #   * later, whenever optional dependencies appear/disappear.
  # - Provide both "enable" and "disable" sides using serviceInstalled/serviceNotInstalled.
  #
  # PER-COMMAND OPTIONS:
  # - timeoutSeconds: <int>        # Kill the command after N seconds (0=no timeout)
  # - continueOnError: true|false  # If true, do not stop the sequence on this command's failure
  # - sudo: true|false             # If true, UI will prompt once per job
  # -----------------------------------------------------------------------------
  lifecycle:
    preInstall:
      commands:                                # optional – prepare system (repos, deps, docker)
        # - command: "apt-get update"
        #   sudo: true
        #   timeoutSeconds: 60
        #   continueOnError: false

    install:
      commands:                                # required – actual installation steps
        - command: "<install command 1>"
          sudo: true
          # timeoutSeconds: 300
          # continueOnError: false
        - command: "<install command 2>"
          sudo: true
        # Examples:
        # - command: "apt-get install -y avnav"
        #   sudo: true
        # - command: "docker pull signalk/signalk-server:latest"
        #   sudo: true

    postInstall:
      commands:                                # optional – config/enable/start after install
        # - command: "systemctl enable --now <service>"
        #   sudo: true

    reconfigure:    # Re-run-able, condition-aware config/integration step
      commands:
        # --- EXAMPLE: Enable integration when SignalK is present
        # - command: "/usr/local/bin/enable-signalk --host 127.0.0.1 --port ${inputs.SIGNALK_PORT}"
        #   sudo: true
        #   onlyIf:
        #     serviceInstalled:
        #       - id: "signalk"
        #         version: ">=2.0.0"
        #
        # --- EXAMPLE: Disable integration (rollback) when SignalK is absent
        # - command: "/usr/local/bin/disable-signalk"
        #   sudo: true
        #   continueOnError: true      # Best-effort rollback
        #   onlyIf:
        #     serviceNotInstalled: "signalk"

    update:
      package_manager: "<apt|docker|docker-compose|npm|pip|custom>"  # required – how to update
      custom_commands:
        - command: "<update command>"
          sudo: true
        # - command: "docker pull myimage:latest && docker restart mysvc"
        #   sudo: true

    uninstall:
      commands:                                # required – clean removal (stop, rm files/containers)
        - command: "<uninstall command 1>"
          sudo: true

    checkInstall:
      command: "<which binary || test -f /path/to/installed/file>"   # required – exit 0 if installed
      sudo: false

  # -----------------------------------------------------------------------------
  # service: How NautiPi manages the running service (start/stop/status).
  # Choose ONE type and fill its subsection. Others can be omitted.
  # -----------------------------------------------------------------------------
  service:
    type: "<systemd|docker|docker-compose|process|custom|none>"   # required

    systemd:
      unit: "<service.service>"             # if type=systemd – unit name to manage

    docker:
      image: "<docker-repo/image:tag>"      # if type=docker – image to run
      name: "<container_name>"              # optional – container name
      ports:
        - "3000:3000"                       # optional – host:container (can use ${inputs.WEB_PORT}:3000)
      volumes:
        # - "/host/path:/container/path"
      env:                                  # optional – inline env for 'docker run'
        # ENV_VAR: "value"
      envFile:                              # optional – host env-file(s)
        # - "/opt/<service>/.env"
      args: "<additional docker run args>"  # optional – appended to 'docker run'

    docker-compose:
      file: "<path/to/docker-compose.yml>"  # if type=docker-compose – compose file
      project: "<project-name>"             # optional – compose project (defaults to metadata.id)

    process:
      start: "<start-command>"              # if type=process – how to start
      stop: "<stop-command>"                # how to stop
      pidFile: "<path/to/pid.file>"         # optional – PID file for status
      cwd: "<working-directory>"            # optional – working directory

    custom:
      start:                                # if type=custom – explicit start/stop/status commands
        - command: "<custom start command>"
          sudo: true
      stop:
        - command: "<custom stop command>"
          sudo: true
      status:
        - command: "<custom status command>"
          sudo: true

  # -----------------------------------------------------------------------------
  # statusChecks: Define one or more health checks. All required checks must pass.
  # Types:
  # - systemd: { unit }
  # - http:    { url, expect("200" or regex), timeout }
  # - tcp:     { host, port }
  # - process: { name }
  # - custom:  { command, expect(regex) }
  # Interpolation works in URLs/hosts/ports (e.g., http://localhost:${inputs.WEB_PORT}/)
  #
  # The reconciler uses statusChecks along with dependencies to drive convergence.
  # -----------------------------------------------------------------------------
  statusChecks:
    - type: "systemd"
      unit: "<service.service>"
    - type: "http"
      url: "http://localhost:3000/status"
      expect: "200"
      timeout: 5
    # - type: "tcp"
    #   host: "localhost"
    #   port: 1883
    # - type: "process"
    #   name: "<process-name>"
    # - type: "custom"
    #   command: "curl -fsS http://localhost:3000/health"
    #   expect: "ok"

  # -----------------------------------------------------------------------------
  # config: (OPTIONAL) – Structured config files + UI editor schema
  #
  # GOAL
  # - Provide a simple form-based editor for common config files (yaml/json/xml/ini/properties/env/conf).
  #
  # FILES
  # - files[]: one or more config sources.
  #   - path (required): absolute file path on host (strings support ${inputs.*})
  #   - format (required): "yaml" | "json" | "xml" | "ini" | "properties" | "env" | "conf" | "file"
  #       yaml/json: parsed with dot-paths (arrays via [index])
  #       ini:       "section.key" or just "key" (no section)
  #       properties: flat "key"
  #       env:       flat "KEY" (KEY=VAL lines)
  #       conf:      flat key=value (like sysconfig) – parser treats as simple map
  #       xml:       XPath OR simplified "a.b.c" path; use "@attr" for attributes (see schema.key)
  #       file:      raw text editor only (no schema-based fields)
  #   - reload (required): what to do after save
  #       "none" (default), or any shell command to run (e.g., "systemctl restart <svc>").
  #       Interpolation works: "docker restart ${inputs.CONTAINER_NAME}"
  #   - reloadSudo (required): true|false – run the reload command with sudo
  #   - description (optional): shown above the editor/form
  #   - writeSudo/createIfMissing/backupSuffix/atomicWrite/owner/group/mode (optional):
  #       safe write controls for system files (see example below)
  #
  # SCHEMA (per file)
  # - schema[]: array defining form fields mapped to keys inside the file.
  #   Field:
  #     - key (required): path to value inside the file
  #     - type (required): string | integer | number | boolean | password | select
  #     - required (optional): true/false
  #     - description (optional): help text
  #     - default (optional): default if key absent (strings support ${inputs.*})
  #     - min / max (optional): numbers only
  #     - minLength / maxLength / pattern (optional): strings only (pattern is regex)
  #     - enum (optional): array of allowed values (for select OR restrict string)
  #     - enumNames (optional): labels for enum entries (UI nicety)
  #
  # NOTES / LIMITS
  # - Comments in yaml/ini may be lost on write (parser dependent). Use format "file" if preserving exact text matters.
  # - Arrays: use explicit indices (e.g., "servers[0].port").
  # - Interpolation applies to all STRING fields (path, reload, defaults, etc.).
  # -----------------------------------------------------------------------------
  config:
    files:
      # Structured file with form schema
      - path: "/etc/<service>/config.yaml"     # supports ${inputs.*}
        format: "yaml"                          # yaml|ini|json|xml|env|conf|properties|file
        reload: "systemctl restart <service>"   # "none" or a shell command (interpolation allowed)
        reloadSudo: true
        # Safe write options (recommended on system configs)
        writeSudo: true                 # Write file with sudo
        createIfMissing: true           # Create missing file/dirs before write
        owner: "root"                   # chown after write (optional)
        group: "root"                   # chgrp after write (optional)
        mode: "0644"                    # chmod after write (optional)
        description: "Main configuration"
        schema:
          - key: "server.port"
            type: integer
            required: true
            description: "HTTP Port"
            min: 1024
            max: 65535
          - key: "auth.enabled"
            type: boolean
            description: "Enable authentication"
          # Examples of other field types:
          # - key: "auth.mode"
          #   type: select
          #   enum: ["none", "basic"]
          #   enumNames: ["No auth", "Basic Auth"]
          # - key: "admin.password"
          #   type: password
          #   required: false
          #   description: "Admin password (leave blank to keep current)"
          # - key: "listeners[0].host"
          #   type: string
          #   default: "0.0.0.0"

      # Raw file (no form fields) – shows a simple text editor
      - path: "/etc/<service>/sub-config.conf"
        format: "file"
        reload: "none"
        reloadSudo: false
        # Safe write options also available for raw files:
        writeSudo: false               # Set true if file requires root to edit
        description: "Additional configuration"

  # -----------------------------------------------------------------------------
  # actions (OPTIONAL):
  # Extra buttons in UI that run commands (backup, reset, etc.).
  # NOTE: start/stop/restart for systemd/docker are handled automatically.
  # Fields: name, command, sudo, confirm, description, icon, builtin
  # -----------------------------------------------------------------------------
  actions:
    # - name: "Restart Service"
    #   command: "systemctl restart <service>"
    #   sudo: true
    #   confirm: false
    #   description: "Restart the service"
    #
    # - name: "Backup Config"
    #   command: "/usr/bin/<service>-backup"
    #   sudo: true
    #   confirm: true
    #   description: "Backup configuration and data"
    #
    # - name: "Apply Integrations"
    #   builtin: "reconfigure"            # Runs lifecycle.reconfigure.commands
    #   confirm: false
    #   description: "Re-run conditional integration & rollback steps"

  # -----------------------------------------------------------------------------
  # links: Helpful URLs shown in UI (e.g., Web UI, Docs).
  # Use localhost or explicit host:port; the UI may rewrite to the device IP.
  # Interpolation works (e.g., http://localhost:${inputs.WEB_PORT}/).
  # IMPORTANT: NautiPi runs HTTP-only on local networks; do not assume TLS.
  # -----------------------------------------------------------------------------
  links:
    - title: "Web UI"
      url: "http://localhost:3000/"
      description: "Open the service web interface"
      webservice: true       # Major button to the service itself
    # - title: "Documentation"
    #   url: "http://project.docs.url"
    #   description: "Project documentation"
    #   webservice: false

  # -----------------------------------------------------------------------------
  # dependsOn: Declare relationships to other services by ID.
  # - required: service MUST be present (installer may block until installed).
  # - optional: service enhances functionality if present (no hard block).
  # Version constraints are advisory (semver, e.g., >=1.0.0).
  # NOTE: Declaration does not auto-install dependencies; it informs UI/flows and health model.
  # -----------------------------------------------------------------------------
  dependsOn:
    required: []   # e.g., [{ id: "database", version: ">=1.0.0" }]
    optional: []   # e.g., [{ id: "signalk",  version: ">=1.0.0" }]
