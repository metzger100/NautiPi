# =============================================================================
# NautiPi Service YAML Template
# =============================================================================
# PURPOSE
# - Declaratively describe how NautiPi installs, configures, runs, checks and links a service.
# - Keep backend simple: most logic should be CLI commands in lifecycle.*.commands.
#
# STRING INTERPOLATION
# - You can reference any user input from `inputs:` in ANY STRING field using: ${inputs.NAME}
#   Example: "-p ${inputs.SIGNALK_PORT}:3000" or "http://localhost:${inputs.WEB_PORT}/"
# - Interpolation happens AFTER YAML parse and BEFORE execution.
# - Escaping: write \${inputs.NAME} to keep it literal (no interpolation).
# - Types: interpolation yields strings; the runner will coerce obvious numeric/boolean fields
#   (e.g. ports[].port) when possible.
# - Validation: if an input is `required: true` but missing, the runner will fail with a clear error.
# - Only add `inputs` that you actually need for install/config (every input becomes UI work).
#
# LOGGING & SECRETS
# - inputs[].type: password OR inputs[].secret: true → mask values in logs/UI (e.g., ******).
# - Never log full expanded commands containing secrets.
#
# =============================================================================

apiVersion: nautipi.io/v1                   # required – API version (fixed)
kind: Service                               # required – always "Service"

metadata:
  id: "<service-id>"                        # required – unique, machine-readable (a-z0-9-_)
  displayName: "<Service Name>"             # required – short UI name (≤ 30 chars)
  version: "1.0.0"                          # required – semver for THIS descriptor (not the app)
  description: |                            # required – 1–3 lines: what this service does
    <Short description of the service or plugin functionality>
  author: "<Author or Project>"             # optional – credits in UI
  homepage: "<https://project.url>"         # optional – docs/homepage

# -----------------------------------------------------------------------------
# inputs: Values collected from the user (once) and available everywhere via ${inputs.NAME}
# Fields:
# - name (required): machine name [A-Z0-9_ recommended]; used as ${inputs.NAME}
# - label (required): shown in UI
# - type (required): string | number | boolean | password
# - default (optional): default value if user doesn't change it
# - required (optional): true/false, default false
# - secret (optional): true to mask in logs/UI (implied when type=password)
# - description (optional): help text in UI
# - pattern / min / max (optional): basic validation hints (optional)
# Keep this section minimal; prefer sensible defaults.
# -----------------------------------------------------------------------------
inputs:
  # Example inputs (delete if not needed):
  # - name: "WEB_PORT"
  #   label: "Web Port"
  #   type: "number"
  #   default: 3000
  #   description: "HTTP port the service will listen on"
  #
  # - name: "ADMIN_USER"
  #   label: "Admin User"
  #   type: "string"
  #   required: true
  #
  # - name: "ADMIN_PASS"
  #   label: "Admin Password"
  #   type: "password"
  #   required: true
  #   secret: true
  #
  # - name: "ENABLE_WRITEBACK"
  #   label: "Allow write-back to upstream"
  #   type: "boolean"
  #   default: true

# -----------------------------------------------------------------------------
# injection (ADVANCED / OPTIONAL):
# Prefer shell-based config in lifecycle.postInstall commands for MVP.
# Use injection only if you must template files declaratively.
# -----------------------------------------------------------------------------
# injection:
#   - input: "<INPUT_NAME>"
#     target:
#       type: "<env_file|docker_compose|replace_string>"
#       file: "<path/to/file>"
#       # for type=env_file: provide key
#       key: "<ENV_KEY>"
#       # for type=docker_compose: YAML path to set (dot notation)
#       key_path: "services.app.environment.MY_VAR"
#       # for type=replace_string: placeholder to replace
#       search: "<PLACEHOLDER>"

spec:
  category: "<navigation|sensor|system|utility|media|plugin>"   # required – UI grouping
  icon: "<icon-name>"                                           # optional – UI icon identifier

  # -----------------------------------------------------------------------------
  # lifecycle: How to install/update/remove and configure the service.
  # Each commands[].command is a shell line; set sudo:true if root is needed.
  # Use ${inputs.NAME} directly in commands via interpolation (see header).
  # Make commands IDEMPOTENT where possible (use '|| true', check existence, etc.).
  # -----------------------------------------------------------------------------
  lifecycle:
    preInstall:
      commands:                                # optional – prepare system (repos, deps)
        # - command: "apt-get update"
        #   sudo: true

    install:
      commands:                                # required – actual installation steps
        # Examples:
        # - command: "apt-get install -y avnav"
        #   sudo: true
        # - command: "docker pull signalk/signalk-server:latest"
        #   sudo: true
        - command: "<install command 1>"
          sudo: true
        - command: "<install command 2>"
          sudo: true

    postInstall:
      commands:                                # optional – config/enable/start after install
        # Tips:
        # - Quote user values that may contain spaces: '--user \"${inputs.ADMIN_USER}\"'
        # - Configure files via sed/xmlstarlet/yq, or call a small helper script.
        # - Example (docker run using interpolated port & creds):
        # - command: >
        #     docker run -d --restart unless-stopped --name mysvc
        #     -p ${inputs.WEB_PORT}:3000
        #     -e ADMINUSER=${inputs.ADMIN_USER}:${inputs.ADMIN_PASS}
        #     -v /opt/mysvc:/data myimage:latest
        #   sudo: true
        # - command: "systemctl restart mysvc || true"
        #   sudo: true
        # - command: "<post-install command or script>"
        #   sudo: true

    update:
      package_manager: "<apt|docker|docker-compose|npm|pip|custom>"  # required – how to update
      # If package_manager != custom, core can do generic updates (e.g., apt-get upgrade mypkg).
      # For custom flows (git pull, special CLI), list commands here:
      custom_commands:
        # - command: "docker pull myimage:latest && docker restart mysvc"
        #   sudo: true
        - command: "<update command>"
          sudo: true

    uninstall:
      commands:                                # required – clean removal (stop, rm files/containers)
        # Make it idempotent: ignore-not-found, use || true
        # - command: "systemctl stop mysvc || true"
        #   sudo: true
        # - command: "docker rm -f mysvc || true"
        #   sudo: true
        # - command: "rm -rf /opt/mysvc"
        #   sudo: true
        - command: "<uninstall command 1>"
          sudo: true

    checkInstall:
      command: "<which binary || test -f /path/to/installed/file>"   # required – exit 0 if installed
      sudo: false

  # -----------------------------------------------------------------------------
  # service: How NautiPi manages the running service (start/stop/status).
  # Choose ONE type and fill its subsection. Others can be omitted.
  # -----------------------------------------------------------------------------
  service:
    type: "<systemd|docker|docker-compose|process|custom|none>"   # required

    systemd:
      unit: "<service.service>"             # if type=systemd – unit name to manage

    docker:
      image: "<docker-repo/image:tag>"      # if type=docker – image to run
      name: "<container_name>"              # optional – container name
      ports:
        - "3000:3000"                       # optional – host:container (can use ${inputs.WEB_PORT}:3000)
      volumes:
        # - "/host/path:/container/path"
      env:                                  # optional – inline env for 'docker run'
        # ENV_VAR: "value"
      envFile:                              # optional – host env-file(s)
        # - "/opt/<service>/.env"
      args: "<additional docker run args>"  # optional – appended to 'docker run'

    docker-compose:
      file: "<path/to/docker-compose.yml>"  # if type=docker-compose – compose file
      project: "<project-name>"             # optional – compose project (defaults to metadata.id)

    process:
      start: "<start-command>"              # if type=process – how to start
      stop: "<stop-command>"                # how to stop
      pidFile: "<path/to/pid.file>"         # optional – PID file for status
      cwd: "<working-directory>"            # optional – working directory

    custom:
      start:                                # if type=custom – define explicit start/stop/status commands
        - command: "<custom start command>"
          sudo: true
      stop:
        - command: "<custom stop command>"
          sudo: true
      status:
        - command: "<custom status command>"
          sudo: true

  # -----------------------------------------------------------------------------
  # statusChecks: Define one or more health checks. All required checks must pass.
  # Types:
  # - systemd: { unit }
  # - http:    { url, expect("200" or regex), timeout }
  # - tcp:     { host, port }
  # - process: { name }
  # - custom:  { command, expect(regex) }
  # Interpolation works in URLs/hosts/ports (e.g., http://localhost:${inputs.WEB_PORT}/)
  # -----------------------------------------------------------------------------
  statusChecks:
    - type: "systemd"
      unit: "<service.service>"
    - type: "http"
      url: "http://localhost:3000/status"
      expect: "200"
      timeout: 5
    # - type: "tcp"
    #   host: "localhost"
    #   port: 1883
    # - type: "process"
    #   name: "<process-name>"
    # - type: "custom"
    #   command: "curl -fsS http://localhost:3000/health"
    #   expect: "ok"

  # -----------------------------------------------------------------------------
  # ports: Document used ports (for UI + conflict checks).
  # Fields:
  # - port (number or ${inputs.PORT})
  # - protocol: "http" | "https" | "tcp" | "udp"
  # - description: human-readable purpose
  # - urlPath: optional default path for opening/checking (e.g., "/")
  # - tls: true/false if https
  # - editable: whether users may change this port in UI
  # - interface: bind address, e.g., "0.0.0.0" (all) or "127.0.0.1" (local only)
  # -----------------------------------------------------------------------------
  ports:
    - port: 3000
      protocol: "http"
      description: "Web Interface"
      urlPath: "/"
      tls: false
      editable: false
      interface: "0.0.0.0"
    # - port: ${inputs.WEB_PORT}
    #   protocol: "http"
    #   description: "Web UI (configurable)"
    #   editable: true
    #   interface: "0.0.0.0"

  # -----------------------------------------------------------------------------
  # config (ADVANCED / OPTIONAL):
  # UI-managed config files. Prefer shell-based config in postInstall for MVP.
  # If used:
  # - name: label in UI
  # - path: absolute path on host
  # - editable: allow UI view/edit (read-only if false)
  # - source: optional template content with ${inputs.*} placeholders
  # -----------------------------------------------------------------------------
  config:
    # - name: "Main Configuration"
    #   path: "/etc/<service>/config.conf"
    #   description: "Primary service configuration."
    #   editable: true
    #   source: |
    #     listen = ${inputs.WEB_PORT}
    #     feature = enabled

  # -----------------------------------------------------------------------------
  # actions (OPTIONAL):
  # Extra buttons in UI that run commands (backup, reset, etc.).
  # NOTE: start/stop/restart for systemd/docker are usually handled automatically.
  # Fields: name, command, sudo, confirm, description, icon
  # -----------------------------------------------------------------------------
  actions:
    # - name: "Restart Service"
    #   command: "systemctl restart <service>"
    #   sudo: true
    #   confirm: false
    #   description: "Restart the service"
    #   icon: "refresh"

    # - name: "Backup Config"
    #   command: "/usr/bin/<service>-backup"
    #   sudo: true
    #   confirm: true
    #   description: "Backup configuration and data"
    #   icon: "archive"

  # -----------------------------------------------------------------------------
  # links: Helpful URLs shown in UI (e.g., Web UI, Docs).
  # Use localhost or explicit host:port; the UI may rewrite to the device IP for convenience.
  # Interpolation works (e.g., http://localhost:${inputs.WEB_PORT}/).
  # -----------------------------------------------------------------------------
  links:
    - title: "Web UI"
      url: "http://localhost:3000/"
      description: "Open the service's web interface"
    # - title: "Documentation"
    #   url: "<https://project.docs.url>"
    #   description: "Project documentation"

  # -----------------------------------------------------------------------------
  # dependsOn: Declare relationships to other services by ID.
  # - required: service MUST be present (installer may block until installed).
  # - optional: service enhances functionality if present (no hard block).
  # Version constraints are advisory (semver, e.g., >=1.0.0).
  # NOTE: Declaration does not auto-install dependencies; it informs UI/flows.
  # -----------------------------------------------------------------------------
  dependsOn:
    required: []   # e.g., [{ id: "database", version: ">=1.0.0" }]
    optional: []   # e.g., [{ id: "signalk",  version: ">=1.0.0" }]
